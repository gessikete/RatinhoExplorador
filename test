local composer = require( "composer" )

local scene = composer.newScene()

local tiled = require "com.ponywolf.ponytiled"

local physics = require "physics"

local json = require "json"

physics.start()


--------------
-- Declaração das variáveis
--------------
-- necessária para fixar joystick na tela
local uiGroup

local map

local character

local joystick
-- setas do joystick
local joystickRight
local joystickLeft
local joystickDown
local joystickUp
local joystickScreen

-- contador de passos que será mostrado na tela
local stepsCount = 0

-- texto que mostra os passos dentro do joystick
local stepsText 

-- tamanho dos tiles usados no tiled
local tilesSize = 16


-- fila de instruções
instructionsQueue = { first = 0, last = -1,  direction = { }, steps = { } }

-- -----------------------------------------------------------------------------------
-- Code outside of the scene event functions below will only be executed ONCE unless
-- the scene is removed entirely (not recycled) via "composer.removeScene()"
-- -----------------------------------------------------------------------------------

function instructionsQueue:add ( direction, steps )
  local queue = self

  queue.last = queue.last + 1
  queue.direction[queue.last] = direction
  queue.steps[queue.last] = steps
end

function instructionsQueue:remove ( )
  local queue = self
  local first = queue.first 
  local last = queue.last

  if ( first > last ) then
    rval = -1
    print ( "A fila ja esta vazia" )
  else 
    local rval = queue.direction[first]
    self.steps[first] = nil 
    self.direction[first] = nil 
    self.first = first + 1
  end

  return rval 
end

-- Recalcula posição do personagem 
-- Cada passo é equivalente a 16px (um tileSize)
local function moveCharacter( direction, steps ) 
  local moveOffset = tilesSize*steps
  local newMapPosition


  if ((direction == "left") or (direction == "right")) then
    newMapPosition = map.x - moveOffset

    -- não deixa personagem sair da tela pelo lado esquerdo
    if ( newMapPosition > 0 ) then
      newMapPosition = 0

      if ( (character.x + moveOffset) > tilesSize ) then 
        character.x = character.x + moveOffset - tilesSize
      else
        character.x = tilesSize
        newMapPosition = tilesSize
      end

    -- não deixa personagem sair pela direita
    elseif ( newMapPosition < -display.contentHeight ) then
      newMapPosition = -display.contentHeight

      if ( (character.x + moveOffset ) < map.designedWidth ) then
        character.x = character.x + moveOffset
      else
        character.x = map.designedWidth - tilesSize*2
      end

    -- não tem perigo do personagem sair da tela
    else 
      map.x = newMapPosition
      character.x = character.x + moveOffset
    end 
  elseif ( (direction == "up") or (direction == "down") ) then
    newMapPosition = map.y - moveOffset
    -- impedir que personagem saia da tela por cima
    if ( newMapPosition > 0 ) then
      map.y = 0

      if ( (character.y + moveOffset ) >= 0 ) then
        character.y = character.y + moveOffset
      else
        character.y = tilesSize
      end

    elseif ( newMapPosition < -display.contentWidth ) then
      map.y = -display.contentWidth

      if ( ( character.y + moveOffset) <= map.designedHeight ) then
        character.y = character.y + moveOffset
      else 
        character.y = map.designedHeight - tilesSize
      end

    else 
      map.y = newMapPosition
      character.y = character.y + moveOffset
    end
  else print ( "Direcao inexistente" )
  end
end

local function defineDirection( event )
  local joystickArrow = event.target
  return joystickArrow.myName
end

-- Define número de passos que o jogador dará em uma dada instrução e
-- mostra a atualização deles na tela do joystick
local function defineSteps( event )
  local phase = event.phase
  local offset

  if ( "began" == phase ) then
    display.currentStage:setFocus( joystickScreen )

    --calcula offset inicial
    joystickScreen.touchOffsetY = event.y - joystickScreen.y
  
  elseif ( "moved" == phase ) then
    if (event.y >= joystickScreen.y ) then
      --calcula novo offset à medida que jogador sobe ou desce na tela do joystick
      offset = (event.y - joystickScreen.y)

      -- caso o novo offset seja maior, o número de passos aumenta
      if ( offset > joystickScreen.touchOffsetY ) then 
        
        -- o 3000 garante que o contador de passos não irá aumentar
        -- rápido demais
        stepsCount = stepsCount - offset/3000

        -- o offset deve ser atualizado para a próxima chamada do "move"
        joystickScreen.touchOffsetY = offset
      else 
        stepsCount = stepsCount + offset/1700

      end

      -- verifica se o número de passos não está negativo  
      if ( stepsCount >= 0) then
        stepsText.text = math.floor(stepsCount)
      else

        -- zera os passos caso esteja
        stepsCount = 0
        stepsText.text = 0

      end 
    end
  elseif ( "ended" == phase or "cancelled" == phase ) then
      display.currentStage:setFocus( nil )
  end

  return true
end


-- -----------------------------------------------------------------------------------
-- Cenas
-- -----------------------------------------------------------------------------------

-- create()
function scene:create( event )

  local sceneGroup = self.view

  -- Cria mapa a partir do arquivo JSON exportado pelo tiled
  display.setDefault("magTextureFilter", "nearest")
  display.setDefault("minTextureFilter", "nearest")
  local mapData = json.decodeFile(system.pathForFile("imgs/tiles/tilemap.json", system.ResourceDirectory))  -- load from json export
  map = tiled.new(mapData, "imgs/tiles")

  -- Posiciona tela no meio do mapa (eixo y)
  map.y = display.viewableContentHeight - map.designedHeight/2

  -- Cria joystick a partir de outro arquivo JSON 
  -- Não está no mesmo JSON do mapa porque assim é possível
  -- garantir que o joystick não irá se mover quando o mapa
  -- sair de lugar
  local joystickData = json.decodeFile(system.pathForFile("imgs/tiles/joystick.json", system.ResourceDirectory))  -- load from json export
  joystick = tiled.new(joystickData, "imgs/tiles")

  -- posiciona joystick no canto direito da tela
  joystick.x, joystick.y = display.contentHeight, display.contentCenterY
  
  --@TODO: TIRAR ISSO QUANDO ACABAREM OS TESTES COM A TELA
  local dragable = require "com.ponywolf.plugins.dragable"
  map = dragable.new(map)


  -- atribuição das referências para os objetos
  character = map:findObject("character")
  character.myName = "character"

  joystickRight = joystick:findObject("right") 
  joystickRight.myName = "right"

  joystickLeft = joystick:findObject("left") 
  joystickLeft.myName = "left"

  joystickDown = joystick:findObject("down") 
  joystickDown.myName = "down"

  joystickUp = joystick:findObject("up") 
  joystickUp.myName = "up"

  joystickScreen = joystick:findObject("joystickScreen")

  stepsCount = 0
  stepsText = display.newText( joystick, 0, joystickScreen.x, joystickScreen.y, "DS-DIGIT.ttf", 50 )
  stepsText:setFillColor( 0, 0, 0 )

end


-- show()
function scene:show( event )

  local sceneGroup = self.view
  local phase = event.phase

  if ( phase == "will" ) then
    -- criar os listeners para mover o character por meio do joystick
    joystickRight:addEventListener( "tap", defineDirection )
    joystickLeft:addEventListener( "tap", defineDirection )
    joystickDown:addEventListener( "tap", defineDirection )
    joystickUp:addEventListener( "tap", defineDirection )

    joystickScreen:addEventListener( "touch", defineSteps )
  elseif ( phase == "did" ) then
     moveCharacter( "up", 15 )
    print (display.actualContentWidth)

  end
end


-- hide()
function scene:hide( event )

  local sceneGroup = self.view
  local phase = event.phase

  if ( phase == "will" ) then
    -- Code here runs when the scene is on screen (but is about to go off screen)

  elseif ( phase == "did" ) then
    -- Code here runs immediately after the scene goes entirely off screen

  end
end


-- destroy()
function scene:destroy( event )

  local sceneGroup = self.view
  -- Code here runs prior to the removal of scene's view

end


-- -----------------------------------------------------------------------------------
-- Scene event function listeners
-- -----------------------------------------------------------------------------------
scene:addEventListener( "create", scene )
scene:addEventListener( "show", scene )
scene:addEventListener( "hide", scene )
scene:addEventListener( "destroy", scene )
-- -----------------------------------------------------------------------------------

return scene
